---
id: getting-started
title: Getting Started
slug: /getting-started
sidebar_position: 0
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

## What is Aigentic?

Aigentic is a Kotlin Multiplatform library that provides a powerful DSL for building and integrating AI agents into applications. It streamlines the process of creating, deploying, and managing LLM agents within your software ecosystem. Aigentic is designed to be model-agnostic, supporting various LLM providers including OpenAI, Gemini, Ollama, and more.

## Installation

Aigentic can be added to your project using Gradle, the preferred build tool for Kotlin projects.

### Kotlin Multiplatform

Add the following to your `build.gradle.kts` file:

```kotlin
plugins {
    kotlin("jvm") version "2.1.21"

    // Kotlinx serialization enables @AigenticParameter to convert Kotlin classes
    // to LLM-compatible formats in order to provide a type safe DSL
    kotlin("plugin.serialization") version "2.1.21"
}

dependencies {
    // Core module
    implementation("community.flock.aigentic:core:{{AIGENTIC_VERSION}}")

    // Provider modules (choose the ones you need)
    implementation("community.flock.aigentic:openai:{{AIGENTIC_VERSION}}")
    implementation("community.flock.aigentic:gemini:{{AIGENTIC_VERSION}}")
    implementation("community.flock.aigentic:ollama:{{AIGENTIC_VERSION}}")
    implementation("community.flock.aigentic:vertexai:{{AIGENTIC_VERSION}}")

    // Tools modules (optional)
    implementation("community.flock.aigentic:http:{{AIGENTIC_VERSION}}")
    implementation("community.flock.aigentic:openapi:{{AIGENTIC_VERSION}}")

}

```

---

## Example

Let's create a simple AI agent using Aigentic that can answer questions and perform basic tasks. This example demonstrates how to set up an agent with the OpenAI provider and add a simple tool.

### Creating a Basic Agent

First, let's create a basic agent that can answer questions using OpenAI's GPT model:

```kotlin
// Define the agents response type
@AigenticParameter
data class Answer(val answer: String)

// Create a simple agent, define it's in- and output type
val agent = agent<String, Answer> {

    // Configure the Gemini model for the agent
    geminiModel {
        apiKey("YOUR_API_KEY")
        modelIdentifier(GeminiModelIdentifier.Gemini2_5Flash)
    }

    // Configure the task for the agent
    task("Answer questions about Kotlin Multiplatform") {
        addInstruction("Provide concise and accurate answers")
    }
}
// Start the agent and get a run
val run = agent.start("What is cool about kotlin?")

// Evaluate the run outcome
when (val outcome = run.outcome) {
    // Finished: Contains the successful response from the agent
    // It yields the O type from the agent: agent<String, Answer>. Access the response property to get the answer
    is Outcome.Finished -> println(outcome.response?.answer)

    // Stuck: Indicates the agent couldn't proceed with execution
    // Access the reason property to understand why the agent got stuck
    is Outcome.Stuck -> println("Agent is stuck: ${outcome.reason}")

    // Fatal: Represents a critical technical error during execution
    // Access the message property to get the error details
    is Outcome.Fatal -> println("Error: ${outcome.message}")
}
```

### Adding Tools to Your Agent

Now, let's enhance our agent by adding a tool that can fetch weather information:

```kotlin
// Describe the agents response type
@AigenticParameter
data class WeatherResponse(
    @Description("Current temperature in degrees Celsius")
    val temperature: Double,
    @Description("Current weather conditions description")
    val conditions: String,
    @Description("Name of the location for the weather data")
    val location: String
)

// Describe the agents task input type
@AigenticParameter
data class WeatherQuestion(
  val city: String,
  val country: String
)

suspend fun main() {

    val agent = agent<WeatherQuestion, WeatherResponse> {

        // Configure the Gemini model for the agent
        geminiModel {
            apiKey("YOUR_API_KEY")
            modelIdentifier(GeminiModelIdentifier.Gemini2_0Flash)
        }

        // Configure the task for the agent
        task("Provide weather information") {
            addInstruction("Respond to user queries about weather")
        }

        // Add a weather tool
        addTool("getWeather", "Get the current weather for a location") { req: WeatherQuestion ->
            WeatherClient.requestWeather(req.city, req.country)
        }
    }

    val run = agent.start(WeatherQuestion("Amsterdam", "Netherlands"))

    // Print the result
    when (val outcome = run.outcome) {
        is Outcome.Finished -> println("Weather in ${outcome.response?.location}: ${outcome.response?.temperature}Â°C, ${outcome.response?.conditions}")
        is Outcome.Stuck -> println("Agent is stuck: ${outcome.reason}")
        is Outcome.Fatal -> println("Error: ${outcome.message}")
    }
}
```

:::caution Don't forget the Kotlinx serialization plugin
To use the @AigenticParameter annotation, you must include the Kotlinx serialization plugin in your build configuration. This plugin generates the metadata Aigentic needs to process your custom types when communicating with LLMs.
:::

## More Examples
The Aigentic Initializr repository contains many ready-to-use example projects, including agents for various use cases, tools implementations, and provider configurations. You can find these examples at [Aigentic Initializr repository](https://github.com/flock-community/aigentic-initializr). We encourage you to explore these examples to better understand how to structure your own AI agents and integrate different tools and providers.

