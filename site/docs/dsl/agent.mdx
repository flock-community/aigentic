---
id: agent
title: Agents
sidebar_position: 1
---

# Agents

Aigentic provides a powerful DSL for creating and configuring AI agents. The DSL is designed to be expressive, type-safe, and easy to use, allowing you to create sophisticated AI agents with minimal boilerplate code.

## Creating an Agent

The main entry point for creating an agent is the `agent` function, which takes a lambda with `AgentConfig` as the receiver:

```kotlin
val myAgent = agent {
    geminiModel {
        apiKey("your-api-key")
        modelIdentifier(GeminiModelIdentifier.Gemini2_0Flash)
    }
    task("Answer questions about the weather") {
        addInstruction("Provide accurate and concise weather information")
        addInstruction("If you don't know the answer, say so")
    }
    addTool(weatherTool)
}
```

## Agent Configuration

The `AgentConfig` class provides several methods for configuring an agent:

### Setting the Model

```kotlin
agent {
    model(openAIModel {
        apiKey("your-api-key")
        modelIdentifier(OpenAIModelIdentifier.GPT4O)
        generationConfig {
            temperature(0.5f)
        }
    })
}
```

### Defining Tasks

Tasks define what the agent should do. A task has a description and can have multiple instructions:

```kotlin
agent {
    task("Summarize text") {
        addInstruction("Create a concise summary of the provided text")
        addInstruction("Highlight key points and main ideas")
        addInstruction("Keep the summary under 200 words")
    }
}
```

### Adding Tools

Tools extend an agent's capabilities by allowing it to perform specific actions:

```kotlin
agent {
    // Add a pre-defined tool
    addTool(weatherTool)

    // Add a tool with inline definition
    addTool<WeatherRequest, WeatherResponse>(
        name = "getWeather",
        description = "Get the current weather for a location",
    ) { request ->
        // Tool implementation
        weatherService.getWeather(request.location)
    }
}
```

### Adding Context

Context provides additional information to the agent that applies to all runs of the agent:

```kotlin
agent {
    context {
        addText("This is some background information the agent should know.")
        addBase64(encodedImage, MimeType.PNG)
    }
}
```

**Note**: Context is built into the agent configuration and applies to every execution. For files that vary per request, use attachments in the `start()` function instead. This way you can reuse your agent for different requests.

### Overriding the System Prompt

The system prompt defines the agent's behavior, capabilities, and personality. It's the first message sent to the LLM and sets the foundation for how the agent will operate.

Aigentic provides a sensible default system prompt through the `DefaultSystemPromptBuilder`, which includes instructions about:
- The agent's purpose and mode of operation
- How to use tools
- Task description and specific instructions
- Task completion protocol

You only need to override the system prompt when you want to customize the agent's behavior beyond the default settings.

```kotlin

val customSystemPromptBuilder = object : SystemPromptBuilder {
        override fun buildSystemPrompt(agent: Agent): Message.SystemPrompt {
            return Message.SystemPrompt("""
                You are a specialized customer service agent for a tech company.

                Your primary task is: ${agent.task.description}

                Follow these specific instructions:
                ${agent.task.instructions.joinToString("\n") { "- ${it.text}" }}

                Always be polite, concise, and helpful. Use a friendly tone.
                When you've completed your task, use the ${FINISHED_TASK_TOOL_NAME} tool.
                If you're stuck, use the ${STUCK_WITH_TASK_TOOL_NAME} tool.
            """.trimIndent())
        }
    }

// Creating a custom system prompt builder
agent {
    systemPrompt(customSystemPromptBuilder)
}
```

The `SystemPromptBuilder` interface has a single method `buildSystemPrompt(agent: Agent)` that returns a `Message.SystemPrompt`. This gives you access to the agent's configuration, including its task, instructions, and tools, allowing you to create a highly customized system prompt.

### Configuring Response Format

You can specify the format for the agent's final response using generic types:

```kotlin
@AigenticParameter
data class Answer(val answer: String)

// Using generic types to specify the output type
val myAgent = agent<Unit, Answer> {
    // Agent configuration
}

// If you need to specify both input and output types
@AigenticParameter
data class Question(val text: String)
val myAgent = agent<Question, Answer> {
    // Agent configuration
}

// If you don't specify types, the default is Agent<Unit, Unit>
val myAgent = agent {
    // Agent configuration
}
```

When using the generic types approach, the agent will automatically be configured to handle the specified input and output types.

## Running an Agent

To run an agent, use the `start` function which returns an `AgentRun`:

```kotlin
val agent = agent<String, Answer> {
    // Agent configuration
}

val run = agent.start("What is Kotlin?")
```

### Running an Agent with Attachments

You can provide files and images to agents using the attachments parameter. Aigentic provides convenient factory functions for creating attachments:

```kotlin
val agent = agent {
    geminiModel {
        apiKey("your-api-key")
        modelIdentifier(GeminiModelIdentifier.Gemini2_5Flash)
    }
    task("Extract information from the provided document") {
        addInstruction("Read the document and extract key information")
    }
    addTool(extractionTool)
}

// Pass a PDF attachment
val run = agent.start(Attachment.Base64.pdf(pdfBase64Content))

// Pass multiple attachments
val run = agent.start(
    Attachment.Base64.pdf(invoiceBase64),
    Attachment.Base64.jpeg(receiptBase64),
    Attachment.Url.png("https://example.com/signature.png")
)
```

Available attachment factory functions:
- **Base64 attachments**: `Attachment.Base64.pdf()`, `jpeg()`, `png()`, `webp()`, `heic()`, `heif()`
- **URL attachments**: `Attachment.Url.pdf()`, `jpeg()`, `png()`, `webp()`, `heic()`, `heif()`

You can also specify input data along with attachments:

```kotlin
@AigenticParameter
data class ProcessingRequest(val instruction: String)

val run = agent.start(
    ProcessingRequest("Please summarize this document"),
    Attachment.Base64.pdf(documentBase64)
)
```

### Processing Agent Results

The `AgentRun` contains everything you need to work with the agent's execution:

```kotlin
when (val outcome = run.outcome) {
    is Outcome.Finished -> {
        val answer = outcome.response?.answer
        println("The agent's answer is: $answer")
    }
    is Outcome.Stuck -> println("Agent is stuck: ${outcome.reason}")
    is Outcome.Fatal -> println("Agent encountered an error: ${outcome.message}")
}

// Access execution details
println("Execution time: ${run.finishedAt - run.startedAt}")
println("Token usage: ${run.tokenUsage()}")
```

The `response` property contains the type you specified when creating the agent, and `AgentRun` gives you access to timing information, token usage, and the complete conversation history.

## More Examples

For more examples and reference implementations, check out the [Aigentic Initializr repository](https://github.com/flock-community/aigentic-initializr). This repository contains various agent configurations and use cases that demonstrate different aspects of the Aigentic DSL:

- Basic agent configurations
- Tool integrations
- Custom system prompts
- Complex response formats
- Context handling examples
- And more...

Feel free to explore the repository and use these examples as a starting point for your own agent implementations.
