---
id: tools
title: Tools
sidebar_position: 3
---

# Tool Definition

Tools extend an agent's capabilities by allowing it to perform specific actions or access external systems. Aigentic provides a flexible DSL for defining and using tools.

## Tool Parameters

Tool parameters define the in- and output structure for a tool. Aigentic has capabilities to automatically derive parameters from data classes annotated with the @AigenticParameter annotation:

```kotlin
@AigenticParameter
data class MessageParameters(
    @Description("The Slack channel to send the message to (e.g., '#general', '@username')")
    val channel: String,
    @Description("The message text content to send to the Slack channel")
    val text: String,
)

@AigenticParameter
data class SlackWebhookResponse(
    @Description("Indicates whether the Slack webhook message was sent successfully")
    val isSuccess: Boolean,
)
```

### @AigenticParameter

The `@AigenticParameter` annotation marks data classes that serve as input or output parameters for tools or agents in the Aigentic framework. This annotation enables Aigentic to automatically derive parameter schemas for the LLM.

Key features:
- Applied at data classes
- Has an optional `description` property that provides a high-level description of the parameter object

### @Description

The `@Description` annotation marks properties within parameter data classes with additional information about their meaning. These descriptions are used by Aigentic to generate accurate documentation and parameter schemas the LLM.

Key features:
- Applied at the property level
- Requires a string value that describes the property's purpose
- Helps LLMs understand the expected input and output formats
- Improves tool usability by providing clear guidance on parameter usage

## Creating Tools

Aigentic provides several ways to create tools:

### Standalone Tool Creation

Use the `createTool` function with type parameters to create a standalone reusable tool:

```kotlin

val slackWebhookTrigger = createTool<MessageParameters, SlackWebhookResponse>("slackWebhookTrigger", "Posts a webhook which sends a message in a channel") { parameters: MessageParameters ->
    // Some code to call a Slack webhook with the MessageParameters provided by the LLM
    SlackWebhookResponse(isSuccess = true)
}
```

This tool can be added to agents:

```kotlin
agent {
  addTool(slackWebhookTrigger)
}
```

### Inline Tool Definition

You can define tools inline:

```kotlin
agent {
    addTool<MessageParameters, SlackWebhookResponse>("slackWebhookTrigger", "Posts a webhook which sends a message in a channel") { parameters: MessageParameters ->
                // Code to call a Slack webhook
                SlackWebhookResponse(true)
            }
}
```

## Best Practices

When creating tools for Aigentic agents, follow these best practices:

1. **Clear Descriptions**: Provide clear and concise descriptions for your tools using the `@AigenticParameter` and `@Description` annotations
2. **Type Safety**: Use strongly typed input and output types
3. **Error Handling**: Implement robust error handling
4. **Idempotency**: Make tools idempotent when possible
5. **Security**: Validate inputs and handle sensitive data carefully

```kotlin
// Example of a well-designed tool
val emailTool = createTool<EmailRequest, EmailResponse>(
    name = "sendEmail",
    description = "Send an email to a recipient"
) { request ->
    // Validate input
    require(request.to.isNotEmpty()) { "Recipient email cannot be empty" }
    require(request.subject.isNotEmpty()) { "Email subject cannot be empty" }

    // Execute with error handling
    runCatching {
        val result = emailService.sendEmail(
            to = request.to,
            subject = request.subject,
            body = request.body
        )

        EmailResponse(success = true, messageId = result.messageId)
    }.getOrElse { error ->
        EmailResponse(success = false, error = error.message)
    }
}
```
